use rand::Rng;

/// FunÃ§Ã£o para calcular o mÃ¡ximo divisor comum (MDC)
fn gcd(a: u128, b: u128) -> u128 {
    if b == 0 {
        a
    } else {
        gcd(b, a % b)
    }
}

/// FunÃ§Ã£o para calcular o inverso modular (d tal que e*d â‰¡ 1 mod Ï†)
fn mod_inverse(e: u128, phi: u128) -> u128 {
    let (mut t, mut new_t) = (0i128, 1i128);
    let (mut r, mut new_r) = (phi as i128, e as i128);

    while new_r != 0 {
        let quotient = r / new_r;
        (t, new_t) = (new_t, t - quotient * new_t);
        (r, new_r) = (new_r, r - quotient * new_r);
    }

    if t < 0 {
        t += phi as i128;
    }

    t as u128
}

/// Teste simples de primalidade (nÃ£o otimizado, mas suficiente para fins didÃ¡ticos)
fn is_prime(n: u128) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }
    let mut i = 3;
    while i * i <= n {
        if n % i == 0 {
            return false;
        }
        i += 2;
    }
    true
}

/// Gera um nÃºmero primo aleatÃ³rio de determinado intervalo
fn generate_prime(min: u128, max: u128) -> u128 {
    let mut rng = rand::thread_rng();
    loop {
        let candidate = rng.gen_range(min..max);
        if is_prime(candidate) {
            return candidate;
        }
    }
}

/// ExponenciaÃ§Ã£o modular rÃ¡pida
fn mod_pow(mut base: u128, mut exp: u128, modulus: u128) -> u128 {
    if modulus == 1 {
        return 0;
    }
    let mut result = 1u128;
    base = base % modulus;
    while exp > 0 {
        if exp % 2 == 1 {
            result = (result * base) % modulus;
        }
        exp >>= 1;
        base = (base * base) % modulus;
    }
    result
}

/// FunÃ§Ã£o principal RSA
fn main() {
    // 1ï¸âƒ£ GeraÃ§Ã£o de chaves
    let p = generate_prime(1000, 5000);
    let q = generate_prime(1000, 5000);
    let n = p * q;
    let phi = (p - 1) * (q - 1);
    let e = 65537u128; // valor comum

    // Garante que e e phi sejam coprimos
    if gcd(e, phi) != 1 {
        println!("Erro: e e Ï†(n) nÃ£o sÃ£o coprimos");
        return;
    }

    let d = mod_inverse(e, phi);

    println!("ğŸ”‘ Chave pÃºblica: (n = {}, e = {})", n, e);
    println!("ğŸ”’ Chave privada: (d = {})", d);

    // 2ï¸âƒ£ Mensagem original
    let message: u128 = 42;
    println!("\nğŸ“© Mensagem original: {}", message);

    // 3ï¸âƒ£ Criptografia: C = M^e mod n
    let cipher = mod_pow(message, e, n);
    println!("ğŸ§® Mensagem criptografada: {}", cipher);

    // 4ï¸âƒ£ Descriptografia: M = C^d mod n
    let decrypted = mod_pow(cipher, d, n);
    println!("âœ… Mensagem descriptografada: {}", decrypted);
}

