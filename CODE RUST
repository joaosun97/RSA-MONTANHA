cargo new rsa_example
cd rsa_example
[dependencies]
num-bigint = "0.4"
num-traits = "0.2"
rand = "0.8"
use num_bigint::{BigInt, RandBigInt, ToBigInt};
use num_traits::{One, Zero};
use rand::thread_rng;

/// Calcula o máximo divisor comum (MDC)
fn gcd(a: &BigInt, b: &BigInt) -> BigInt {
    if b.is_zero() {
        a.clone()
    } else {
        gcd(b, &(a % b))
    }
}

/// Calcula o inverso modular (d tal que e*d ≡ 1 mod φ)
fn mod_inverse(e: &BigInt, phi: &BigInt) -> Option<BigInt> {
    let (mut t, mut new_t) = (BigInt::zero(), BigInt::one());
    let (mut r, mut new_r) = (phi.clone(), e.clone());

    while !new_r.is_zero() {
        let quotient = &r / &new_r;
        t = std::mem::replace(&mut new_t, &t - &quotient * &new_t);
        r = std::mem::replace(&mut new_r, &r - &quotient * &new_r);
    }

    if r > BigInt::one() {
        return None; // sem inverso
    }
    if t < BigInt::zero() {
        t += phi;
    }
    Some(t)
}

/// Teste de primalidade simples (Miller-Rabin seria melhor, mas aqui é suficiente)
fn is_prime(n: &BigInt) -> bool {
    if n <= &BigInt::from(1) {
        return false;
    }
    if n <= &BigInt::from(3) {
        return true;
    }
    if n % 2 == BigInt::zero() {
        return false;
    }
    let mut i = BigInt::from(3);
    while &i * &i <= *n {
        if n % &i == BigInt::zero() {
            return false;
        }
        i += 2;
    }
    true
}

/// Gera um número primo aleatório de determinado tamanho (em bits)
fn generate_prime(bits: usize) -> BigInt {
    let mut rng = thread_rng();
    loop {
        let candidate = rng.gen_bigint(bits as u64);
        let prime_candidate = if candidate.is_negative() {
            -candidate
        } else {
            candidate
        } | BigInt::one(); // garante ímpar
        if is_prime(&prime_candidate) {
            return prime_candidate;
        }
    }
}

/// Geração de chaves RSA
fn generate_keys(bits: usize) -> (BigInt, BigInt, BigInt) {
    let p = generate_prime(bits / 2);
    let q = generate_prime(bits / 2);
    let n = &p * &q;
    let phi = (&p - 1u32) * (&q - 1u32);
    let e = BigInt::from(65537u32); // valor padrão
    let d = mod_inverse(&e, &phi).expect("Não foi possível calcular o inverso modular");
    (n, e, d)
}

/// Criptografa mensagem numérica
fn encrypt(message: &BigInt, e: &BigInt, n: &BigInt) -> BigInt {
    message.modpow(e, n)
}

/// Descriptografa mensagem numérica
fn decrypt(cipher: &BigInt, d: &BigInt, n: &BigInt) -> BigInt {
    cipher.modpow(d, n)
}

fn main() {
    // 1. Gera chaves
    let (n, e, d) = generate_keys(64); // Para teste, use 64 bits; para uso real, use >=2048 bits

    println!("Chave pública (n, e) = ({}, {})", n, e);
    println!("Chave privada (d) = {}", d);

    // 2. Mensagem (em número)
    let message = BigInt::from(42);
    println!("Mensagem original: {}", message);

    // 3. Criptografa
    let cipher = encrypt(&message, &e, &n);
    println!("Mensagem criptografada: {}", cipher);

    // 4. Descriptografa
    let decrypted = decrypt(&cipher, &d, &n);
    println!("Mensagem descriptografada: {}", decrypted);
}
